#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

//算术操作符
//int main()
//{
//	//操作符(运算符)
//	int a = 10 / 3;//对于除法操作符来说，如果两边都是整数，执行的是整数除法
//	double b = 10.0 / 3;//如果想计算出来的是小数，除号两端至少有一个操作符是浮点数
//	int c = 10 % 3;//取模操作符的两边必须是整数，返回整除之后的余数
//
//	printf("%d\n", a);
//	printf("%.3lf\n", b);
//	printf("%d\n", c);
//	return 0;
//}


//移位操作符(二进制)
//内存中存储的起始是补码的二进制
// << 左移操作符
// >> 右移操作符
//移位操作符的操作只能是整数
//移位的不能是正数并且要小于32


//int main()
//{
//	int a = 10;
//	//正数
//	//正数的原码，反码，补码是相同的
//	//10的二进制为1010
//	//整型占4个字节(32bit)
//	//00000000 00000000 00000000 00001010 - /原码
//	//00000000 00000000 00000000 00001010 - /反码
//	//00000000 00000000 00000000 00001010 - /补码
//
//
//    int b = -10;
//	//负数
//	//负数的原码，反码，补码是需要计算的
//	//反码也就是原码符号位（第一位）不变，其他位按位取反
//	//补码在计算上是反码加1，但是不意味着反码加1等于补码
//	//10000000 00000000 00000000 00001010 - /原码
//	//11111111 11111111 11111111 11110101 - /反码
//	//11111111 11111111 11111111 11110110 - /补码
//
//	//负数补码到原码的方法有两种：1.减一取反 2.取反加一
//	
//	return 0;
//}

//左移操作符(左边丢弃，右边补零) 对补码进行操作
//int main()
//{
//	//整数
//	int a = 10;        // 00000000 00000000 00000000 00001010 - 补码
//	int b = a << 1;    // 00000000 00000000 00000000 00010100
//
//	printf("%d\n", a); //a<<1的结果是移位之后的效果，a的值不变
//	printf("%d\n", b);
//
//
//	//负数
//	int c = -10;       // 11111111 11111111 11111111 11110110 - 补码（c）
//	int d = c << 1;    // 11111111 11111111 11111111 11101100 - 补码（d）
//                     // 10000000 00000000 00000000 00010100 - 原码（d）
//
//	printf("%d\n", c);  
//	printf("%d\n", d); //打印出来的是原码
//	return 0;
//}

//右移操作符
//1.算术右移（常见）:右边丢弃，左边补原来的符号位
//2.逻辑右移：右边丢弃，左边补零
//int main()
//{
//	int a = -1;
//	// 10000000 00000000 00000000 00000001
//	// 11111111 11111111 11111111 11111110
//	// 11111111 11111111 11111111 11111111  -1的补码都为1
//
//	int b = a >> 1;
//
//	printf("%d\n", b);//算术右移
//	return 0;
//}


//位操作符（操作数必须是整数，也是针对二进制进行计算的）
//按位与
//按位或
//按位异或

//按位与 &
//对应的二进制有0则为0，两个同时为1才为1
//int main()
//{
//	int a = 3;        // 00000000 00000000 00000000 00000011 - 补码
//	int b = -5;       // 10000000 00000000 00000000 00000101 - 原码
//	                  // 11111111 11111111 11111111 11111011 - 补码
//
//	int c = a & b;    // 00000000 00000000 00000000 00000011 - 补码
//	printf("%d", c);
//	return 0;
//}

//按位或 |
//对应的二进制有1则为1，两个同时为0才为0
//int main()
//{
//	int a = 3;        // 00000000 00000000 00000000 00000011 - 补码
//	int b = -5;       // 10000000 00000000 00000000 00000101 - 原码
//					  // 11111111 11111111 11111111 11111011 - 补码
//
//	int c = a | b;    // 11111111 11111111 11111111 11111011 - 补码
//	printf("%d", c);
//	return 0;
//}

//按位异或 ^
//对应的二进制相同为0，相异为1
//a^a = 0   a^0 = a   a^b^c = a^c^b 
//int main()
//{
//	int a = 3;        // 00000000 00000000 00000000 00000011 
//	int b = -5;       // 10000000 00000000 00000000 00000101 - 原码
//					  // 11111111 11111111 11111111 11111011 - 补码
//
//	int c = a ^ b;    // 11111111 11111111 11111111 11111000
//	printf("%d", c);
//	return 0;
//}


//不创建临时变量来实现两个数的交换
//异或操作符交换两个变量的坏处
//1.代码可读性差
//2.效率不如使用临时变量的方法高
//3.异或只能针对整数的交换
//int main()
//{
//	int a = 3;
//	int b = 5;
//    printf("%d %d\n", a, b);
//
//	a = a ^ b;
//	b = a ^ b;//相当于b = a^b^b = a
//	a = a ^ b;//相当于a = a^b^a = b
//	printf("%d %d\n", a, b);
//	return 0;
//}


//取地址符和间接访问操作符（解引用操作符）
//int main()
//{
//	int a = 10;
//	printf("%p", &a);
//	int* p1 = &a;
//	
//	char ch = 'w';
//	char* p2 = &ch;
//
//	char arr[10] = { 0 };
//	char* p3 = arr;
//	char* p4 = &arr[0];
//
//	char* p5 = "abcdef";
//	printf("%p\n", p5);
//	printf("%c\n", *p5);
//	return 0;
//}


//int main()
//{
//	int a = 10;
//	printf("%d\n", a);
//	int* pa = &a;
//	*pa = 20;//解引用操作
//	printf("%d\n", a);
//	return 0;
//}


//sizeof操作符
//int main()
//{
//	int a = 10;
//	short s = 5;
//	printf("%d\n", sizeof(short));
//	printf("%d\n", sizeof(s = a + 3));//最终由s决定，也就是short
//	printf("%d\n", s);//sizeof内部的表达式是不计算的
//	return 0;
//}


//对二进制按位取反 ~
//int main()
//{
//	int a = 0;// 000000000 00000000 00000000 00000000
//	          // 111111111 11111111 11111111 11111111 - 补码，对应-1
//	printf("%d", ~a);//-1
//	return 0;
//}

//int main()
//{
//	int a = 9;
//	// 00000000 00000000 00000000 00001001
//	// 00000000 00000000 00000000 00010000  1<<4
//	// 00000000 00000000 00000000 00011001
//	// 把a的二进制中第五位改成1
//	a |= (1 << 4);
//	printf("%d\n", a);
//
//	// 把a的二进制中第五位改回0
//	// 00000000 00000000 00000000 00011001
//	// 11111111 11111111 11111111 11101111
//	// 00000000 00000000 00000000 00001001
//	a &= (~(1 << 4));
//	printf("%d\n", a);
//	return 0;
//}