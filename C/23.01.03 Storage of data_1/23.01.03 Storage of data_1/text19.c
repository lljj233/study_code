#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>

//在计算机系统中，数值一律用补码来表示和存储

//int main()
//{
//	int a = 20;
//	int b = -10;
//
//	// 20是正数，原码，反码，补码都一样
//	// 00000000 00000000 00000000 00010100 - 原码
//	// 00000000 00000000 00000000 00010100 - 反码
//	// 00000000 00000000 00000000 00010100 - 补码
//	// 00 00 00 14 - 十六进制
//	// 实际上存储的是 14 00 00 00
//
//	// -10是负数
//	// 10000000 00000000 00000000 00001010 - 原码
//	// 11111111 11111111 11111111 11110101 - 反码（符号位不变，其余位按位取反）
//	// 11111111 11111111 11111111 11110110 - 补码
//	// ff ff ff f6 - 十六进制
//	// 实际上存储的是 f6 ff ff ff
//	return 0;
//}


//假设一个地址为0x 11 22 33 44
//          高位             低位  
//大端存储（大端字节序存储）：11 22 33 44 - 高位字节数据放在低地址处
//小端存储（小端字节序存储）：44 33 22 11 - 低位字节数据放在低地址处
//int main()
//{
//	int a = 0x11223344;
//	return 0;
//}



//通过代码判断是大端存储还是小端存储

//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		printf("小端存储");
//	}
//	else
//	{
//		printf("大端存储");
//	}
//	return 0;
//}

//int check_sys()//如果是小端存储返回1，大端存储返回0
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (*p == 1)
//		return 1;
//	else
//		return 0;
//}
//int main()
//{
//	int ret = check_sys();
//	if(ret==1)
//		printf("小端存储");
//	else
//		printf("大端存储");
//	return 0;
//}

//int check_sys()//如果是小端存储返回1，大端存储返回0
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端存储");
//	else
//		printf("大端存储");
//	return 0;
//}



//int main()
//{
//	char a = -1;
//	// 10000000 00000000 00000000 00000001 - 原码
//	// 11111111 11111111 11111111 11111110 - 反码
//	// 11111111 11111111 11111111 11111111 - 补码
//	// char只能存一个字节（8bit），即最后的八位 11111111 - a  截断
//	// 整型提升 11111111 11111111 11111111 11111111 - a - 补码
//	// 00000000 00000000 00000000 00000001 - 原码 - -1
//
//	signed char b = -1;
//	// 同上，signed char == char
//
//	unsigned char c = -1;
//	// 10000000 00000000 00000000 00000001 - 原码
//	// 11111111 11111111 11111111 11111110 - 反码
//	// 11111111 11111111 11111111 11111111 - 补码
//	// char只能存一个字节（8bit），即最后的八位 11111111 - a  截断
//	// 无符号整型提升高位补零 00000000 00000000 00000000 11111111 - a - 补码
//	// 00000000 00000000 00000000 11111111 - 原码 - 255
//
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	// %d打印的是有符号的整数
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	// 10000000 00000000 00000000 10000000 - 原码
//	// 11111111 11111111 11111111 01111111 - 反码
//	// 11111111 11111111 11111111 10000000 - 补码
//	// 10000000 - 截断
//	// 整型提升 - 11111111 11111111 11111111 10000000 - 补码，也是原码
//
//	printf("%u", a);
//	// %u打印的是无符号的整数
//	return 0;
//}

//int main()
//{
//	char a = 128;
//	// 00000000 00000000 00000000 10000000 - 原码
//	// 01111111 11111111 11111111 01111111 - 反码
//	// 01111111 11111111 11111111 10000000 - 补码
//	// 10000000 - 截断
//	// 整型提升 - 11111111 11111111 11111111 10000000 - 补码，也是原码
//
//	printf("%u", a);
//	// %u打印的是无符号的整数
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	// 10000000 00000000 00000000 00010100 - i的原码
//	// 11111111 11111111 11111111 11101011 - i的反码
//	 
//	// 11111111 11111111 11111111 11101100 - i的补码
//	// 00000000 00000000 00000000 00001010 - j的补码
//	// 11111111 11111111 11111111 11110110 - i+j的补码  
//	// 10000000 00000000 00000000 00001010 - i+j的原码 - -10
//
//	printf("%d", i + j);
//	return 0;
//}

//int main()
//{
//	unsigned int i ;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//-1,-2,-3....-128,127,126...3,2,1,0,-1,-2...
//	printf("%d\n", strlen(a));//'0' -- 0
//	return 0;
//}

//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello\n");
//	}
//	return 0;
//}



//浮点型在内存中的存储

//浮点数没有原码反码补码的概念
//所有的浮点数都可以写成该形式v=(-1)^s * M * 2^E
//假设存在十进制浮点数v=5.5，转换成二进制为101.1，即1.011*2^2,即（-1）^0*1.011*2^2
//对于32位的浮点数（单精度），最高的1位是S，接着的8位是E，剩下的23位是M
//对于64位的浮点数（双精度），最高的1位是S，接着的11位是E，剩下的52位是M
//M只存小数点后的数字

//E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1

//E全为0
//这时，浮点数的指数E等于1 - 127（或者1 - 1023）即为真实值

//E全为1
//这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）

//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//
//	printf("n的值为：%d\n",n);
//	printf("*pfloat的值为：%f\n",*pFloat);//说明整型和浮点型的存储方式不一样
//
//	*pFloat = 9.0;
//	printf("n的值为：%d\n", n);
//	printf("*pfloat的值为：%f\n", *pFloat);
//	return 0;
//}

//int main()
//{
//	float f = 5.5f;
//	//101.1
//	//1.011*2^2
//	//(-1)^0*1.011*2^2
//	//S=0,M=1.011,E=2
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//40 b0 00 00 - 十六进制
//	return 0;
//}

//int main()
//{
//	float f = 9.0f;
//	//1001.0
//	//1.001*2^3
//	//(-1)^0*1.011*2^2
//	//S=0,M=1.001,E=3
//	//0 10000010 00100000000000000000000
//	//0100 0001 0001 0000 0000 0000 0000 0000
//	//41 10 00 00
//	return 0;
//}


//int main()
//{
//	int n = 9;
//	//00000000 00000000 00000000 00001001 - 9的补码
//	//0 0000000 000000000000000000001001
//	//S   E          M
//	//(-1)^0*0.000000000000000000001001*2^-126
//	//0.0000000
//	float* pFloat = (float*)&n;
//
//	printf("n的值为：%d\n",n);//9
//	printf("*pfloat的值为：%f\n",*pFloat);//0.0000000
//
//	*pFloat = 9.0;
//	//1001.0
//	//1.001*2^3
//	//(-1)^0*1.011*2^2
//	//S=0,M=1.001,E=3
//	//0 10000010 00100000000000000000000
//	//1091567616
//	printf("n的值为：%d\n", n);
//	printf("*pfloat的值为：%f\n", *pFloat);
//	return 0;
//}